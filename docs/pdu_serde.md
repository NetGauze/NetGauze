# Packet Representation and Serde

NetGauze relies heavily on the rust's rich type system to represent packets in the away that allows the rust compiler
help the user to construct correct packets at compile time.

1. PDU are immutable once constructed.

2. For constants, use `enum` to list the possible values. For example, if the PDU has a type field with limited set
   of options, then NetGauze uses an enum to represent them.

### Example PDU

```rust
use strum_macros::{Display, FromRepr};

// Make sure the type is represented the same way it would be in the PDU, here it's a one unassigned octet.
// Derive [strum_macros::FromRepr] to make it easier to create the enum from a numerical value 
#[repr(u8)]
#[derive(Display, FromRepr, Copy, Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
pub enum OuterPDUType {
    APdu = 1,
    BPdu = 2,
}

// The From<> helps to encode the enum back to it basic numerical value.
// This is helpful in serializing the packets
impl From<OuterPDUType> for u8 {
    fn from(value: OuterPDUType) -> Self {
        value as u8
    }
}

// Always create meaningful error types
#[derive(Copy, Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
pub struct InvalidOuterPDUType(pub u8);

// The idea here, is to always use TryFrom when deserializing the PDU type,
// hence we can always get meaningful errors 
impl TryFrom<u8> for OuterPDUType {
    type Error = InvalidOuterPDUType;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match Self::from_repr(value) {
            Some(val) => Ok(val),
            None => Err(InvalidOuterPDUType(value)),
        }
    }
}

// With this enum construction we always guaranteed to produce a valid type for the PDU
pub enum OuterPDU {
    APdu(APdu),
    BPdu(APdu),
}

#[repr(u8)]
#[derive(Display, FromRepr, Copy, Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
pub enum APdu {
    Val1,
    Val2,
}

// The From<> helps to encode the enum back to it basic numerical value.
// This is helpful in serializing the packets
impl From<APdu> for u8 {
    fn from(value: APdu) -> Self {
        value as u8
    }
}

// Always create meaningful error types
#[derive(Copy, Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
pub struct InvalidAPduType(pub u8);

// The idea here, is to always use TryFrom when deserializing the PDU type,
// hence we can always get meaningful errors 
impl TryFrom<u8> for APdu {
    type Error = InvalidAPduType;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match Self::from_repr(value) {
            Some(val) => Ok(val),
            None => Err(InvalidAPduType(value)),
        }
    }
}


#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct BPdu {
    value: u16
}

impl BPdu {
    pub const fn new(value: u16) -> Self { Self { value } }
    pub const fn value(&self) -> u16 { self.value }
}
```

## PDU Deserialization

### Main principles

* NetGauze uses [nom](https://github.com/geal/nom) as the primary parser.
* In order to deserialize PDUs efficiently, NetGauze provides a fork
  of [nom_locate](https://github.com/fflorent/nom_locate). See [netgauze-locate](../crates/locate/README.md).
* [netgauze-parse-utils](../crates/parse-utils) provides the essential traits to handle PDUs parsing. And
  optionally, testing helpers for unit testing.
* In case if there is any deserialization error, the first error must be reported effectively, that includes
    * Exactly location in the byte stream of where the parsing error occurred
    * Custom informative error type return for the PDU or part of the PDU that encountered an error.

### Example PDU deserializer

Here we show an example structure of parsing

```rust
// Custom error type for parsing the OuterPDU
#[derive(Eq, PartialEq, Clone, Debug)]
pub enum OuterPDUParsingError {
    // Those are errors generated by nom parser, 
    // includes errors like EoF for reaching the end of byte stream while still expecting more data
    NomError(nom::error::ErrorKind),
    // Errors carried from parsing the APdu payload 
    APduError(APduParsingError),
    // Errors carried from parsing the APdu payload 
    BPduError(BPduParsingError),
}


// This struct, carries the OuterPDUParsingError along with the location where it happened
#[derive(Eq, PartialEq, Clone, Debug)]
pub struct LocatedOuterPDUParsingError<'a> {
    span: Span<'a>,
    error: OuterPDUParsingError,
}


// Trait to be able to treat all the locators the same way
impl<'a> LocatedParsingError for LocatedOuterPDUParsingError<'a> {
    type Span = Span<'a>;
    type Error = OuterPDUParsingError;

    fn span(&self) -> &Self::Span {
        &self.span
    }

    fn error(&self) -> &Self::Error {
        &self.error
    }
}


// To automatically convert nom errors into our located type. Helpful when using ? after each parser.
impl<'a> ParseError<Span<'a>> for LocatedOuterPDUParsingError<'a> {
    fn from_error_kind(input: Span<'a>, kind: ErrorKind) -> Self {
        LocatedOuterPDUParsingError::new(input, OuterPDUParsingError::NomError(kind))
    }
    fn append(_input: Span<'a>, _kind: ErrorKind, other: Self) -> Self {
        other
    }
}

// To automatically convert custom errors into our located type. Helpful when using ? after each parser.
impl<'a> FromExternalError<Span<'a>, OuterPDUParsingError> for LocatedOuterPDUParsingError<'a> {
    fn from_external_error(
        input: Span<'a>,
        _kind: ErrorKind,
        error: OuterPDUParsingError,
    ) -> Self {
        LocatedOuterPDUParsingError::new(input, error)
    }
}

// Helpful to auto translate custom errors defined the PDU model into a located error.
impl<'a> FromExternalError<Span<'a>, InvalidOuterPDUType> for LocatedOuterPDUParsingError<'a>
{
    fn from_external_error(
        input: Span<'a>,
        _kind: ErrorKind,
        error: InvalidOuterPDUType,
    ) -> Self {
        LocatedOuterPDUParsingError::new(
            input,
            InvalidOuterPDUType::UndefinedCapabilityCode(error),
        )
    }
}


```
                 
  