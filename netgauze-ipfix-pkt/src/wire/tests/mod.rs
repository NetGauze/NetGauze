// Copyright (C) 2022-present The NetGauze Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use chrono::{TimeZone, Timelike, Utc};
use netgauze_parse_utils::{test_helpers::*, ReadablePDUWithOneInput, Span};
use std::{cell::RefCell, collections::HashMap, net::Ipv4Addr, rc::Rc};

use crate::{
    ie,
    wire::{
        deserializer::{ie as ie_desr, *},
        serializer::{ie as ie_ser, *},
    },
    DataRecord, FieldSpecifier, Flow, IpfixHeader, IpfixPacket, OptionsTemplateRecord, Set,
    SetPayload, TemplateRecord,
};

#[test]
fn test_ipfix_header() {
    let good_wire = [
        0x00, 0x0a, 0x00, 0x10, 0x63, 0x4a, 0xe2, 0x9d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x01,
    ];
    let bad_version_wire = [
        0x00, 0x00, 0x00, 0x10, 0x63, 0x4a, 0xe2, 0x9d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x01,
    ];
    let bad_length_wire = [
        0x00, 0x0a, 0x00, 0x00, 0x63, 0x4a, 0xe2, 0x9d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x01,
    ];

    let good = IpfixHeader::new(
        Utc.with_ymd_and_hms(2022, 10, 15, 16, 41, 01).unwrap(),
        6,
        1,
    );
    let bad_version = LocatedIpfixHeaderParsingError::new(
        Span::new(&bad_version_wire),
        IpfixHeaderParsingError::UnsupportedVersion(0),
    );
    let bad_length = LocatedIpfixHeaderParsingError::new(
        unsafe { Span::new_from_raw_offset(2, &bad_length_wire[2..]) },
        IpfixHeaderParsingError::InvalidLength(0),
    );

    test_parsed_completely(&good_wire, &good);
    test_parse_error::<IpfixHeader, LocatedIpfixHeaderParsingError<'_>>(
        &bad_version_wire,
        &bad_version,
    );
    test_parse_error::<IpfixHeader, LocatedIpfixHeaderParsingError<'_>>(
        &bad_length_wire,
        &bad_length,
    );
}

#[test]
fn test_template_record() -> Result<(), TemplateRecordWritingError> {
    let good_wire = [
        0x08, 0x01, 0x00, 0x02, 0x00, 0x1b, 0x00, 0x10, 0x00, 0x1c, 0x00, 0x10,
    ];
    let bad_template_id_wire = [
        0x00, 0x00, 0x00, 0x02, 0x00, 0x1b, 0x00, 0x10, 0x00, 0x1c, 0x00, 0x10,
    ];

    let good = TemplateRecord::new(
        2049,
        vec![
            FieldSpecifier::new(ie::InformationElementId::sourceIPv6Address, 16),
            FieldSpecifier::new(ie::InformationElementId::destinationIPv6Address, 16),
        ],
    );

    let bad_template_id = LocatedTemplateRecordParsingError::new(
        Span::new(&bad_template_id_wire),
        TemplateRecordParsingError::InvalidTemplateId(0),
    );
    let templates_map = Rc::new(RefCell::new(HashMap::new()));
    test_parsed_completely_with_one_input(&good_wire, templates_map.clone(), &good);
    test_parse_error_with_one_input::<
        TemplateRecord,
        Rc<RefCell<HashMap<u16, Rc<Vec<FieldSpecifier>>>>>,
        LocatedTemplateRecordParsingError<'_>,
    >(&bad_template_id_wire, templates_map, &bad_template_id);
    test_write(&good, &good_wire)?;
    Ok(())
}

#[test]
fn test_field() -> Result<(), FieldSpecifierWritingError> {
    let good_ipv4_src_wire = [0x00, 0x08, 0x00, 0x04];
    let good_ipv4_src = FieldSpecifier::new(ie::InformationElementId::sourceIPv4Address, 4);
    test_parsed_completely(&good_ipv4_src_wire, &good_ipv4_src);
    test_write(&good_ipv4_src, &good_ipv4_src_wire)?;
    Ok(())
}

#[test]
fn test_u8_value() -> Result<(), ie_ser::protocolIdentifierWritingError> {
    let value_wire = [123];
    let value = ie::protocolIdentifier(123);
    let invalid_length = ie_desr::LocatedprotocolIdentifierParsingError::new(
        Span::new(&value_wire),
        ie_desr::protocolIdentifierParsingError::InvalidLength(2),
    );
    test_parsed_completely_with_one_input(&value_wire, 1, &value);
    test_parse_error_with_one_input::<
        ie::protocolIdentifier,
        u16,
        ie_desr::LocatedprotocolIdentifierParsingError<'_>,
    >(&value_wire, 2, &invalid_length);
    test_write_with_one_input(&value, None, &value_wire)?;
    Ok(())
}

#[test]
fn test_mac_address_value() -> Result<(), ie_ser::sourceMacAddressWritingError> {
    let value_wire = [0x12, 0xc6, 0x21, 0x12, 0x69, 0x32];
    let value = ie::sourceMacAddress([0x12, 0xc6, 0x21, 0x12, 0x69, 0x32]);
    let invalid_length = ie_desr::LocatedsourceMacAddressParsingError::new(
        Span::new(&value_wire),
        ie_desr::sourceMacAddressParsingError::InvalidLength(2),
    );
    test_parsed_completely_with_one_input::<
        ie::sourceMacAddress,
        u16,
        ie_desr::LocatedsourceMacAddressParsingError<'_>,
    >(&value_wire, 6u16, &value);
    test_parse_error_with_one_input::<
        ie::sourceMacAddress,
        u16,
        ie_desr::LocatedsourceMacAddressParsingError<'_>,
    >(&value_wire, 2u16, &invalid_length);
    test_write_with_one_input(&value, None, &value_wire)?;
    Ok(())
}

#[test]
fn test_ipv4_address_value() -> Result<(), ie_ser::sourceIPv4AddressWritingError> {
    let good_wire = [0x46, 0x01, 0x73, 0x01];
    let value = ie::sourceIPv4Address(Ipv4Addr::new(70, 1, 115, 1));
    let invalid_length = ie_desr::LocatedsourceIPv4AddressParsingError::new(
        Span::new(&good_wire),
        ie_desr::sourceIPv4AddressParsingError::InvalidLength(2),
    );
    test_parsed_completely_with_one_input::<
        ie::sourceIPv4Address,
        u16,
        ie_desr::LocatedsourceIPv4AddressParsingError<'_>,
    >(&good_wire, 4u16, &value);
    test_parse_error_with_one_input::<
        ie::sourceIPv4Address,
        u16,
        ie_desr::LocatedsourceIPv4AddressParsingError<'_>,
    >(&good_wire, 2u16, &invalid_length);
    test_write_with_one_input(&value, None, &good_wire)?;
    Ok(())
}

#[test]
fn test_pkg_record_value() -> Result<(), ie_ser::RecordWritingError> {
    let value_wire = [0x12, 0xc6, 0x21, 0x12, 0x69, 0x32];
    let value =
        ie::Record::sourceMacAddress(ie::sourceMacAddress([0x12, 0xc6, 0x21, 0x12, 0x69, 0x32]));
    let invalid_length = nom::Err::Error(ie_desr::LocatedRecordParsingError::new(
        Span::new(&value_wire),
        ie_desr::RecordParsingError::sourceMacAddressError(
            ie_desr::sourceMacAddressParsingError::InvalidLength(2),
        ),
    ));
    test_parsed_completely_with_two_inputs::<
        ie::Record,
        &ie::InformationElementId,
        u16,
        ie_desr::LocatedRecordParsingError<'_>,
    >(
        &value_wire,
        &ie::InformationElementId::sourceMacAddress,
        6u16,
        &value,
    );
    test_parse_error_with_two_inputs::<
        ie::Record,
        &ie::InformationElementId,
        u16,
        ie_desr::LocatedRecordParsingError<'_>,
    >(
        &value_wire,
        &ie::InformationElementId::sourceMacAddress,
        2u16,
        invalid_length,
    );

    test_write_with_one_input(&value, None, &value_wire)?;
    Ok(())
}

#[test]
fn test_milli_value() -> Result<(), ie_ser::flowStartMillisecondsWritingError> {
    let good_wire = [0, 0, 1, 88, 177, 177, 56, 255];
    let good = ie::flowStartMilliseconds(
        Utc.with_ymd_and_hms(2016, 11, 29, 20, 05, 31)
            .unwrap()
            .with_nanosecond(519_000_000)
            .unwrap(),
    );
    test_parsed_completely_with_one_input(&good_wire, 8, &good);
    test_write_with_one_input(&good, None, &good_wire)?;
    Ok(())
}

#[test]
fn test_time_fraction_value() -> Result<(), ie_ser::flowStartMicrosecondsWritingError> {
    let good_full_wire = [0x58, 0x3d, 0xdf, 0x8b, 0xff, 0xff, 0xff, 0xff];
    let good_half_wire = [0x58, 0x3d, 0xdf, 0x8b, 0x7f, 0xff, 0xff, 0xff];
    let good_zero_wire = [0x58, 0x3d, 0xdf, 0x8b, 0x00, 0x00, 0x00, 0x00];

    let good_full = ie::flowStartMicroseconds(
        Utc.with_ymd_and_hms(2016, 11, 29, 20, 05, 31)
            .unwrap()
            .with_nanosecond(1_000_000_000)
            .unwrap(),
    );
    let good_half = ie::flowStartMicroseconds(
        Utc.with_ymd_and_hms(2016, 11, 29, 20, 05, 31)
            .unwrap()
            .with_nanosecond(500_000_000)
            .unwrap(),
    );
    // Due to floating point errors, we cannot retrieve the original value.
    let good_half_rounded = ie::flowStartMicroseconds(
        Utc.with_ymd_and_hms(2016, 11, 29, 20, 05, 31)
            .unwrap()
            .with_nanosecond(499_999_999)
            .unwrap(),
    );
    let good_zero = ie::flowStartMicroseconds(
        Utc.with_ymd_and_hms(2016, 11, 29, 20, 05, 31)
            .unwrap()
            .with_nanosecond(0)
            .unwrap(),
    );

    test_parsed_completely_with_one_input(&good_full_wire, 8, &good_full);
    test_parsed_completely_with_one_input(&good_half_wire, 8, &good_half_rounded);
    test_parsed_completely_with_one_input(&good_zero_wire, 8, &good_zero);
    test_write_with_one_input(&good_full, None, &good_full_wire)?;
    test_write_with_one_input(&good_half, None, &good_half_wire)?;
    test_write_with_one_input(&good_zero, None, &good_zero_wire)?;
    Ok(())
}

#[test]
fn test_record_value() -> Result<(), ie_ser::RecordWritingError> {
    let value_wire = [0x12, 0xc6, 0x21, 0x12, 0x69, 0x32];
    let value =
        ie::Record::sourceMacAddress(ie::sourceMacAddress([0x12, 0xc6, 0x21, 0x12, 0x69, 0x32]));
    let invalid_length = nom::Err::Error(ie_desr::LocatedRecordParsingError::new(
        Span::new(&value_wire),
        ie_desr::RecordParsingError::sourceMacAddressError(
            ie_desr::sourceMacAddressParsingError::InvalidLength(2),
        ),
    ));
    test_parsed_completely_with_two_inputs::<
        ie::Record,
        &ie::InformationElementId,
        u16,
        ie_desr::LocatedRecordParsingError<'_>,
    >(
        &value_wire,
        &ie::InformationElementId::sourceMacAddress,
        6u16,
        &value,
    );
    test_parse_error_with_two_inputs::<
        ie::Record,
        &ie::InformationElementId,
        u16,
        ie_desr::LocatedRecordParsingError<'_>,
    >(
        &value_wire,
        &ie::InformationElementId::sourceMacAddress,
        2u16,
        invalid_length,
    );
    test_write_with_one_input(&value, None, &value_wire)?;
    Ok(())
}

#[test]
fn test_data_record() -> Result<(), DataRecordWritingError> {
    let good_wire = [
        0x12, 0xc6, 0x21, 0x12, 0x69, 0x32, 0x12, 0xc6, 0x21, 0x12, 0x69, 0x32,
    ];
    let good_with_padding_wire = [
        0x12, 0xc6, 0x21, 0x12, 0x69, 0x32, 0x12, 0xc6, 0x21, 0x12, 0x69, 0x32, 0x00, 0x00,
    ];
    let flow = Flow::new(vec![
        ie::Record::sourceMacAddress(ie::sourceMacAddress([0x12, 0xc6, 0x21, 0x12, 0x69, 0x32])),
        ie::Record::destinationMacAddress(ie::destinationMacAddress([
            0x12, 0xc6, 0x21, 0x12, 0x69, 0x32,
        ])),
    ]);
    let fields = Rc::new(vec![
        FieldSpecifier::new(ie::InformationElementId::sourceMacAddress, 6),
        FieldSpecifier::new(ie::InformationElementId::destinationMacAddress, 6),
    ]);

    let good = DataRecord::new(vec![flow]);

    test_parsed_completely_with_two_inputs::<
        DataRecord,
        Rc<Vec<FieldSpecifier>>,
        usize,
        crate::wire::deserializer::LocatedDataRecordParsingError<'_>,
    >(&good_wire, fields.clone(), 0, &good);

    test_parsed_completely_with_two_inputs::<
        DataRecord,
        Rc<Vec<FieldSpecifier>>,
        usize,
        crate::wire::deserializer::LocatedDataRecordParsingError<'_>,
    >(&good_with_padding_wire, fields.clone(), 2, &good);
    test_write_with_one_input(&good, None, &good_wire)?;
    Ok(())
}

#[test]
fn test_flow_value() -> Result<(), FlowWritingError> {
    let value_wire = [
        0x12, 0xc6, 0x21, 0x12, 0x69, 0x32, 0x12, 0xc6, 0x21, 0x12, 0x69, 0x32,
    ];

    let flow = Flow::new(vec![
        ie::Record::sourceMacAddress(ie::sourceMacAddress([0x12, 0xc6, 0x21, 0x12, 0x69, 0x32])),
        ie::Record::destinationMacAddress(ie::destinationMacAddress([
            0x12, 0xc6, 0x21, 0x12, 0x69, 0x32,
        ])),
    ]);

    let fields = Rc::new(vec![
        FieldSpecifier::new(ie::InformationElementId::sourceMacAddress, 6),
        FieldSpecifier::new(ie::InformationElementId::destinationMacAddress, 6),
    ]);
    test_parsed_completely_with_one_input::<
        Flow,
        Rc<Vec<FieldSpecifier>>,
        crate::wire::deserializer::LocatedFlowParsingError<'_>,
    >(&value_wire, fields, &flow);
    test_write_with_one_input(&flow, None, &value_wire)?;
    Ok(())
}

#[test]
fn test_set_template() -> Result<(), SetWritingError> {
    let good_wire = [
        0x00, 0x02, 0x00, 0x64, 0x01, 0x33, 0x00, 0x17, 0x00, 0x08, 0x00, 0x04, 0x00, 0x0c, 0x00,
        0x04, 0x00, 0x05, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x07, 0x00, 0x02, 0x00, 0x0b,
        0x00, 0x02, 0x00, 0x20, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x10, 0x00, 0x04, 0x00,
        0x11, 0x00, 0x04, 0x00, 0x12, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x01, 0x00, 0x04,
        0x00, 0x02, 0x00, 0x04, 0x00, 0x16, 0x00, 0x04, 0x00, 0x15, 0x00, 0x04, 0x00, 0x0f, 0x00,
        0x04, 0x00, 0x09, 0x00, 0x01, 0x00, 0x0d, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x3c,
        0x00, 0x01, 0x00, 0x98, 0x00, 0x08, 0x00, 0x99, 0x00, 0x08,
    ];

    let good = Set::new(
        2,
        SetPayload::Template(vec![TemplateRecord::new(
            307,
            vec![
                FieldSpecifier::new(ie::InformationElementId::sourceIPv4Address, 4),
                FieldSpecifier::new(ie::InformationElementId::destinationIPv4Address, 4),
                FieldSpecifier::new(ie::InformationElementId::ipClassOfService, 1),
                FieldSpecifier::new(ie::InformationElementId::protocolIdentifier, 1),
                FieldSpecifier::new(ie::InformationElementId::sourceTransportPort, 2),
                FieldSpecifier::new(ie::InformationElementId::destinationTransportPort, 2),
                FieldSpecifier::new(ie::InformationElementId::icmpTypeCodeIPv4, 2),
                FieldSpecifier::new(ie::InformationElementId::ingressInterface, 4),
                FieldSpecifier::new(ie::InformationElementId::bgpSourceAsNumber, 4),
                FieldSpecifier::new(ie::InformationElementId::bgpDestinationAsNumber, 4),
                FieldSpecifier::new(ie::InformationElementId::bgpNextHopIPv4Address, 4),
                FieldSpecifier::new(ie::InformationElementId::egressInterface, 4),
                FieldSpecifier::new(ie::InformationElementId::octetDeltaCount, 4),
                FieldSpecifier::new(ie::InformationElementId::packetDeltaCount, 4),
                FieldSpecifier::new(ie::InformationElementId::flowStartSysUpTime, 4),
                FieldSpecifier::new(ie::InformationElementId::flowEndSysUpTime, 4),
                FieldSpecifier::new(ie::InformationElementId::ipNextHopIPv4Address, 4),
                FieldSpecifier::new(ie::InformationElementId::sourceIPv4PrefixLength, 1),
                FieldSpecifier::new(ie::InformationElementId::destinationIPv4PrefixLength, 1),
                FieldSpecifier::new(ie::InformationElementId::tcpControlBits, 1),
                FieldSpecifier::new(ie::InformationElementId::ipVersion, 1),
                FieldSpecifier::new(ie::InformationElementId::flowStartMilliseconds, 8),
                FieldSpecifier::new(ie::InformationElementId::flowEndMilliseconds, 8),
            ],
        )]),
    );
    let templates_map = Rc::new(RefCell::new(HashMap::new()));
    test_parsed_completely_with_one_input(&good_wire, templates_map, &good);
    test_write_with_one_input(&good, None, &good_wire)?;
    Ok(())
}

#[test]
fn test_template_packet() -> Result<(), IpfixPacketWritingError> {
    let good_wire = [
        0x00, 0x0a, // Version
        0x00, 0x74, // Length
        0x58, 0x3d, 0xe0, 0x59, // Export time
        0x00, 0x00, 0x0e, 0xe4, // Seq number
        0x00, 0x00, 0x00, 0x00, // Observation domain
        0x00, 0x02, 0x00, 0x64, 0x01, 0x33, 0x00, 0x17, 0x00, 0x08, 0x00, 0x04, 0x00, 0x0c, 0x00,
        0x04, 0x00, 0x05, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x07, 0x00, 0x02, 0x00, 0x0b,
        0x00, 0x02, 0x00, 0x20, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x10, 0x00, 0x04, 0x00,
        0x11, 0x00, 0x04, 0x00, 0x12, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x01, 0x00, 0x04,
        0x00, 0x02, 0x00, 0x04, 0x00, 0x16, 0x00, 0x04, 0x00, 0x15, 0x00, 0x04, 0x00, 0x0f, 0x00,
        0x04, 0x00, 0x09, 0x00, 0x01, 0x00, 0x0d, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x3c,
        0x00, 0x01, 0x00, 0x98, 0x00, 0x08, 0x00, 0x99, 0x00, 0x08,
    ];

    let good = IpfixPacket::new(
        IpfixHeader::new(
            Utc.with_ymd_and_hms(2016, 11, 29, 20, 08, 57).unwrap(),
            3812,
            0,
        ),
        vec![Set::new(
            2,
            SetPayload::Template(vec![TemplateRecord::new(
                307,
                vec![
                    FieldSpecifier::new(ie::InformationElementId::sourceIPv4Address, 4),
                    FieldSpecifier::new(ie::InformationElementId::destinationIPv4Address, 4),
                    FieldSpecifier::new(ie::InformationElementId::ipClassOfService, 1),
                    FieldSpecifier::new(ie::InformationElementId::protocolIdentifier, 1),
                    FieldSpecifier::new(ie::InformationElementId::sourceTransportPort, 2),
                    FieldSpecifier::new(ie::InformationElementId::destinationTransportPort, 2),
                    FieldSpecifier::new(ie::InformationElementId::icmpTypeCodeIPv4, 2),
                    FieldSpecifier::new(ie::InformationElementId::ingressInterface, 4),
                    FieldSpecifier::new(ie::InformationElementId::bgpSourceAsNumber, 4),
                    FieldSpecifier::new(ie::InformationElementId::bgpDestinationAsNumber, 4),
                    FieldSpecifier::new(ie::InformationElementId::bgpNextHopIPv4Address, 4),
                    FieldSpecifier::new(ie::InformationElementId::egressInterface, 4),
                    FieldSpecifier::new(ie::InformationElementId::octetDeltaCount, 4),
                    FieldSpecifier::new(ie::InformationElementId::packetDeltaCount, 4),
                    FieldSpecifier::new(ie::InformationElementId::flowStartSysUpTime, 4),
                    FieldSpecifier::new(ie::InformationElementId::flowEndSysUpTime, 4),
                    FieldSpecifier::new(ie::InformationElementId::ipNextHopIPv4Address, 4),
                    FieldSpecifier::new(ie::InformationElementId::sourceIPv4PrefixLength, 1),
                    FieldSpecifier::new(ie::InformationElementId::destinationIPv4PrefixLength, 1),
                    FieldSpecifier::new(ie::InformationElementId::tcpControlBits, 1),
                    FieldSpecifier::new(ie::InformationElementId::ipVersion, 1),
                    FieldSpecifier::new(ie::InformationElementId::flowStartMilliseconds, 8),
                    FieldSpecifier::new(ie::InformationElementId::flowEndMilliseconds, 8),
                ],
            )]),
        )],
    );

    let templates_map = Rc::new(RefCell::new(HashMap::new()));
    test_parsed_completely_with_one_input(&good_wire, templates_map.clone(), &good);
    assert!(templates_map.borrow().contains_key(&307));

    test_write_with_one_input(&good, None, &good_wire)?;
    Ok(())
}

#[test]
fn test_u64_reduced_size_encoding() -> Result<(), ie_ser::RecordWritingError> {
    let full_wire = [0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88];
    let seven_wire = [0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99];
    let six_wire = [0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa];
    let five_wire = [0xff, 0xee, 0xdd, 0xcc, 0xbb];
    let four_wire = [0xff, 0xee, 0xdd, 0xcc];
    let three_wire = [0xff, 0xee, 0xdd];
    let two_wire = [0xff, 0xee];
    let one_wire = [0xff];

    let field_full = Some(8);
    let field_seven = Some(7);
    let field_six = Some(6);
    let field_five = Some(5);
    let field_four = Some(4);
    let field_three = Some(3);
    let field_two = Some(2);
    let field_one = Some(1);

    let full = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffeeddccbbaa9988));
    let seven = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffeeddccbbaa99));
    let six = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffeeddccbbaa));
    let five = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffeeddccbb));
    let four = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffeeddcc));
    let three = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffeedd));
    let two = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffee));
    let one = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xff));

    test_parsed_completely_with_two_inputs(
        &full_wire,
        &ie::InformationElementId::packetDeltaCount,
        8,
        &full,
    );
    test_parsed_completely_with_two_inputs(
        &seven_wire,
        &ie::InformationElementId::packetDeltaCount,
        7,
        &seven,
    );
    test_parsed_completely_with_two_inputs(
        &six_wire,
        &ie::InformationElementId::packetDeltaCount,
        6,
        &six,
    );
    test_parsed_completely_with_two_inputs(
        &five_wire,
        &ie::InformationElementId::packetDeltaCount,
        5,
        &five,
    );
    test_parsed_completely_with_two_inputs(
        &four_wire,
        &ie::InformationElementId::packetDeltaCount,
        4,
        &four,
    );
    test_parsed_completely_with_two_inputs(
        &three_wire,
        &ie::InformationElementId::packetDeltaCount,
        3,
        &three,
    );
    test_parsed_completely_with_two_inputs(
        &two_wire,
        &ie::InformationElementId::packetDeltaCount,
        2,
        &two,
    );
    test_parsed_completely_with_two_inputs(
        &one_wire,
        &ie::InformationElementId::packetDeltaCount,
        1,
        &one,
    );

    test_write_with_one_input(&full, field_full, &full_wire)?;
    test_write_with_one_input(&seven, field_seven, &seven_wire)?;
    test_write_with_one_input(&six, field_six, &six_wire)?;
    test_write_with_one_input(&five, field_five, &five_wire)?;
    test_write_with_one_input(&four, field_four, &four_wire)?;
    test_write_with_one_input(&three, field_three, &three_wire)?;
    test_write_with_one_input(&two, field_two, &two_wire)?;
    test_write_with_one_input(&one, field_one, &one_wire)?;
    Ok(())
}

#[test]
fn test_u32_reduced_size_encoding() -> Result<(), ie_ser::RecordWritingError> {
    let four_wire = [0xff, 0xee, 0xdd, 0xcc];
    let three_wire = [0xff, 0xee, 0xdd];
    let two_wire = [0xff, 0xee];
    let one_wire = [0xff];

    let field_four = Some(4);
    let field_three = Some(3);
    let field_two = Some(2);
    let field_one = Some(1);

    let four = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffeeddcc));
    let three = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffeedd));
    let two = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffee));
    let one = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xff));

    test_parsed_completely_with_two_inputs(
        &four_wire,
        &ie::InformationElementId::packetDeltaCount,
        4,
        &four,
    );
    test_parsed_completely_with_two_inputs(
        &three_wire,
        &ie::InformationElementId::packetDeltaCount,
        3,
        &three,
    );
    test_parsed_completely_with_two_inputs(
        &two_wire,
        &ie::InformationElementId::packetDeltaCount,
        2,
        &two,
    );
    test_parsed_completely_with_two_inputs(
        &one_wire,
        &ie::InformationElementId::packetDeltaCount,
        1,
        &one,
    );

    test_write_with_one_input(&four, field_four, &four_wire)?;
    test_write_with_one_input(&three, field_three, &three_wire)?;
    test_write_with_one_input(&two, field_two, &two_wire)?;
    test_write_with_one_input(&one, field_one, &one_wire)?;
    Ok(())
}

#[test]
fn test_u16_reduced_size_encoding() -> Result<(), ie_ser::RecordWritingError> {
    let two_wire = [0xff, 0xee];
    let one_wire = [0xff];

    let field_two = Some(2);
    let field_one = Some(1);

    let two = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xffee));
    let one = ie::Record::packetDeltaCount(ie::packetDeltaCount(0xff));

    test_parsed_completely_with_two_inputs(
        &two_wire,
        &ie::InformationElementId::packetDeltaCount,
        2,
        &two,
    );
    test_parsed_completely_with_two_inputs(
        &one_wire,
        &ie::InformationElementId::packetDeltaCount,
        1,
        &one,
    );

    test_write_with_one_input(&two, field_two, &two_wire)?;
    test_write_with_one_input(&one, field_one, &one_wire)?;
    Ok(())
}

#[test]
fn test_i32_reduced_size_encoding() -> Result<(), ie_ser::RecordWritingError> {
    let u32_max_wire = [0x7f, 0xff, 0xff, 0xff];
    let u32_min_wire = [0x80, 0x00, 0x00, 0x00];
    let u24_pos_wire = [0x00, 0x7f, 0xff];
    let u24_neg_wire = [0xff, 0x80, 0x00];
    let u16_max_wire = [0x7f, 0xff];
    let u16_min_wire = [0x80, 0x00];
    let u8_max_wire = [0x7f];
    let u8_min_wire = [0x80];

    let length_four = Some(4);
    let length_three = Some(3);
    let length_two = Some(2);
    let length_one = Some(1);

    let u32_max = ie::Record::mibObjectValueInteger(ie::mibObjectValueInteger(i32::MAX));
    let u32_min = ie::Record::mibObjectValueInteger(ie::mibObjectValueInteger(i32::MIN));
    let u16_max = ie::Record::mibObjectValueInteger(ie::mibObjectValueInteger(i16::MAX as i32));
    let u24_pos = ie::Record::mibObjectValueInteger(ie::mibObjectValueInteger(i16::MAX as i32));
    let u16_neg = ie::Record::mibObjectValueInteger(ie::mibObjectValueInteger(i16::MIN as i32));
    let u24_min = ie::Record::mibObjectValueInteger(ie::mibObjectValueInteger(i16::MIN as i32));
    let u8_max = ie::Record::mibObjectValueInteger(ie::mibObjectValueInteger(i8::MAX as i32));
    let u8_min = ie::Record::mibObjectValueInteger(ie::mibObjectValueInteger(i8::MIN as i32));

    test_parsed_completely_with_two_inputs(
        &u32_max_wire,
        &ie::InformationElementId::mibObjectValueInteger,
        4,
        &u32_max,
    );
    test_parsed_completely_with_two_inputs(
        &u32_min_wire,
        &ie::InformationElementId::mibObjectValueInteger,
        4,
        &u32_min,
    );
    test_parsed_completely_with_two_inputs(
        &u24_pos_wire,
        &ie::InformationElementId::mibObjectValueInteger,
        3,
        &u24_pos,
    );
    test_parsed_completely_with_two_inputs(
        &u24_neg_wire,
        &ie::InformationElementId::mibObjectValueInteger,
        3,
        &u24_min,
    );
    test_parsed_completely_with_two_inputs(
        &u16_max_wire,
        &ie::InformationElementId::mibObjectValueInteger,
        2,
        &u16_max,
    );
    test_parsed_completely_with_two_inputs(
        &u16_min_wire,
        &ie::InformationElementId::mibObjectValueInteger,
        2,
        &u16_neg,
    );
    test_parsed_completely_with_two_inputs(
        &u8_max_wire,
        &ie::InformationElementId::mibObjectValueInteger,
        1,
        &u8_max,
    );
    test_parsed_completely_with_two_inputs(
        &u8_min_wire,
        &ie::InformationElementId::mibObjectValueInteger,
        1,
        &u8_min,
    );

    test_write_with_one_input(&u32_max, length_four, &u32_max_wire)?;
    test_write_with_one_input(&u32_min, length_four, &u32_min_wire)?;
    test_write_with_one_input(&u24_pos, length_three, &u24_pos_wire)?;
    test_write_with_one_input(&u24_min, length_three, &u24_neg_wire)?;
    test_write_with_one_input(&u16_max, length_two, &u16_max_wire)?;
    test_write_with_one_input(&u16_neg, length_two, &u16_min_wire)?;
    test_write_with_one_input(&u8_max, length_one, &u8_max_wire)?;
    test_write_with_one_input(&u8_min, length_one, &u8_min_wire)?;
    Ok(())
}

#[test]
fn test_data_packet() -> Result<(), IpfixPacketWritingError> {
    let good_wire = [
        0x00, 0x0a, // Version
        0x00, 0x60, // Length
        0x58, 0x3d, 0xe0, 0x59, // Export time
        0x00, 0x00, 0x0e, 0xe4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x33, // Set ID
        0x00, 0x50, // Flow Set Length
        0x46, 0x01, 0x73, 0x01, // Source IP
        0x32, 0x00, 0x47, 0x01, // Dest IP
        0x00, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3b, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x03, 0xcc, 0x2a, 0x6e, 0x65, 0x00, 0x00, 0x03, 0x56, 0x00, 0x00,
        0x05, 0x20, 0x00, 0x00, 0x00, 0x09, 0xb3, 0xf9, 0x06, 0xee, 0xb3, 0xfb, 0xaf, 0x3c, 0xcc,
        0x2a, 0x6e, 0xbd, 0x18, 0x18, 0x00, 0x04, 0x00, 0x00, 0x01, 0x58, 0xb1, 0xb1, 0x38, 0xff,
        0x00, 0x00, 0x01, 0x58, 0xb1, 0xb3, 0xe1, 0x4d,
    ];

    let f = vec![
        FieldSpecifier::new(ie::InformationElementId::sourceIPv4Address, 4),
        FieldSpecifier::new(ie::InformationElementId::destinationIPv4Address, 4),
        FieldSpecifier::new(ie::InformationElementId::ipClassOfService, 1),
        FieldSpecifier::new(ie::InformationElementId::protocolIdentifier, 1),
        FieldSpecifier::new(ie::InformationElementId::sourceTransportPort, 2),
        FieldSpecifier::new(ie::InformationElementId::destinationTransportPort, 2),
        FieldSpecifier::new(ie::InformationElementId::icmpTypeCodeIPv4, 2),
        FieldSpecifier::new(ie::InformationElementId::ingressInterface, 4),
        FieldSpecifier::new(ie::InformationElementId::bgpSourceAsNumber, 4),
        FieldSpecifier::new(ie::InformationElementId::bgpDestinationAsNumber, 4),
        FieldSpecifier::new(ie::InformationElementId::bgpNextHopIPv4Address, 4),
        FieldSpecifier::new(ie::InformationElementId::egressInterface, 4),
        FieldSpecifier::new(ie::InformationElementId::octetDeltaCount, 4),
        FieldSpecifier::new(ie::InformationElementId::packetDeltaCount, 4),
        FieldSpecifier::new(ie::InformationElementId::flowStartSysUpTime, 4),
        FieldSpecifier::new(ie::InformationElementId::flowEndSysUpTime, 4),
        FieldSpecifier::new(ie::InformationElementId::ipNextHopIPv4Address, 4),
        FieldSpecifier::new(ie::InformationElementId::sourceIPv4PrefixLength, 1),
        FieldSpecifier::new(ie::InformationElementId::destinationIPv4PrefixLength, 1),
        FieldSpecifier::new(ie::InformationElementId::tcpControlBits, 1),
        FieldSpecifier::new(ie::InformationElementId::ipVersion, 1),
        FieldSpecifier::new(ie::InformationElementId::flowStartMilliseconds, 8),
        FieldSpecifier::new(ie::InformationElementId::flowEndMilliseconds, 8),
    ];
    let fields = Rc::new(f.clone());
    let templates_map = Rc::new(RefCell::new(HashMap::from([(307, fields)])));
    let good = IpfixPacket::new(
        IpfixHeader::new(
            Utc.with_ymd_and_hms(2016, 11, 29, 20, 08, 57).unwrap(),
            3812,
            0,
        ),
        vec![Set::new(
            307,
            SetPayload::Data(vec![DataRecord::new(vec![Flow::new(vec![
                ie::Record::sourceIPv4Address(ie::sourceIPv4Address(Ipv4Addr::new(70, 1, 115, 1))),
                ie::Record::destinationIPv4Address(ie::destinationIPv4Address(Ipv4Addr::new(
                    50, 0, 71, 1,
                ))),
                ie::Record::ipClassOfService(ie::ipClassOfService(0)),
                ie::Record::protocolIdentifier(ie::protocolIdentifier(61)),
                ie::Record::sourceTransportPort(ie::sourceTransportPort(0)),
                ie::Record::destinationTransportPort(ie::destinationTransportPort(0)),
                ie::Record::icmpTypeCodeIPv4(ie::icmpTypeCodeIPv4(0)),
                ie::Record::ingressInterface(ie::ingressInterface(827)),
                ie::Record::bgpSourceAsNumber(ie::bgpSourceAsNumber(2)),
                ie::Record::bgpDestinationAsNumber(ie::bgpDestinationAsNumber(3)),
                ie::Record::bgpNextHopIPv4Address(ie::bgpNextHopIPv4Address(Ipv4Addr::new(
                    204, 42, 110, 101,
                ))),
                ie::Record::egressInterface(ie::egressInterface(854)),
                ie::Record::octetDeltaCount(ie::octetDeltaCount(1312)),
                ie::Record::packetDeltaCount(ie::packetDeltaCount(9)),
                ie::Record::flowStartSysUpTime(ie::flowStartSysUpTime(0xb3f906ee)),
                ie::Record::flowEndSysUpTime(ie::flowEndSysUpTime(0xb3fbaf3c)),
                ie::Record::ipNextHopIPv4Address(ie::ipNextHopIPv4Address(Ipv4Addr::new(
                    204, 42, 110, 189,
                ))),
                ie::Record::sourceIPv4PrefixLength(ie::sourceIPv4PrefixLength(24)),
                ie::Record::destinationIPv4PrefixLength(ie::destinationIPv4PrefixLength(24)),
                ie::Record::tcpControlBits(ie::tcpControlBits(0)),
                ie::Record::ipVersion(ie::ipVersion(4)),
                ie::Record::flowStartMilliseconds(ie::flowStartMilliseconds(
                    Utc.with_ymd_and_hms(2016, 11, 29, 20, 05, 31)
                        .unwrap()
                        .with_nanosecond(519_000_000)
                        .unwrap(),
                )),
                ie::Record::flowEndMilliseconds(ie::flowEndMilliseconds(
                    Utc.with_ymd_and_hms(2016, 11, 29, 20, 08, 25)
                        .unwrap()
                        .with_nanosecond(677_000_000)
                        .unwrap(),
                )),
            ])])]),
        )],
    );
    test_parsed_completely_with_one_input(&good_wire, templates_map, &good);
    test_write_with_one_input(
        &good,
        Some(&f.iter().map(|x| Some(x.length)).collect::<Vec<_>>()),
        &good_wire,
    )?;
    Ok(())
}

#[test]
fn test_options_template_packet() -> Result<(), IpfixPacketWritingError> {
    let good_wire = [
        0x00, 0x0a, // version
        0x00, 0x28, // length
        0x58, 0x3d, 0xe0, 0x57, // timestamp
        0x00, 0x00, 0x0e, 0xcf, // Seq
        0x00, 0x00, 0x00, 0x00, // Domain
        0x00, 0x03, // Set ID
        0x00, 0x18, // Set length
        0x01, 0x34, // Template ID
        0x00, 0x03, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x24, 0x00, 0x02, 0x00, 0x25, 0x00,
        0x02, 0x00, 0x00,
    ];

    let good_no_padding_wire = [
        0x00, 0x0a, // version
        0x00, 0x26, // length
        0x58, 0x3d, 0xe0, 0x57, // timestamp
        0x00, 0x00, 0x0e, 0xcf, // Seq
        0x00, 0x00, 0x00, 0x00, // Domain
        0x00, 0x03, // Set ID
        0x00, 0x16, // Set length
        0x01, 0x34, // Template ID
        0x00, 0x03, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x24, 0x00, 0x02, 0x00, 0x25, 0x00,
        0x02,
    ];

    let good = IpfixPacket::new(
        IpfixHeader::new(
            Utc.with_ymd_and_hms(2016, 11, 29, 20, 08, 55).unwrap(),
            3791,
            0,
        ),
        vec![Set::new(
            3,
            SetPayload::OptionsTemplate(vec![OptionsTemplateRecord::new(
                308,
                vec![FieldSpecifier::new(
                    ie::InformationElementId::ipClassOfService,
                    1,
                )],
                vec![
                    FieldSpecifier::new(ie::InformationElementId::flowActiveTimeout, 2),
                    FieldSpecifier::new(ie::InformationElementId::flowIdleTimeout, 2),
                ],
            )]),
        )],
    );

    let templates_map = Rc::new(RefCell::new(HashMap::new()));
    test_parsed_completely_with_one_input(&good_wire, templates_map.clone(), &good);
    test_parsed_completely_with_one_input(&good_no_padding_wire, templates_map, &good);
    test_write_with_one_input(&good, None, &good_no_padding_wire)?;
    Ok(())
}

#[test]
#[rustfmt::skip]
fn test_complex_sequence() -> Result<(), IpfixPacketWritingError> {
    let templates_map = Rc::new(RefCell::new(HashMap::new()));
    let pkt1_wire = [
     0x00, 0x0a, 0x02, 0x24, 0x63, 0x4a, 0xe2, 0x9d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x02, 0x00, 0x40, 0x04, 0x00, 0x00, 0x0e, 0x00, 0x08, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x04,
     0x00, 0x16, 0x00, 0x04, 0x00, 0x15, 0x00, 0x04, 0x00, 0x01, 0x00, 0x04, 0x00, 0x02, 0x00, 0x04,
     0x00, 0x0a, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x07, 0x00, 0x02, 0x00, 0x0b, 0x00, 0x02,
     0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x3c, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01,
     0x00, 0x02, 0x00, 0x34, 0x04, 0x01, 0x00, 0x0b, 0x00, 0x08, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x04,
     0x00, 0x16, 0x00, 0x04, 0x00, 0x15, 0x00, 0x04, 0x00, 0x01, 0x00, 0x04, 0x00, 0x02, 0x00, 0x04,
     0x00, 0x0a, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x20, 0x00, 0x02, 0x00, 0x3c, 0x00, 0x01,
     0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x40, 0x08, 0x00, 0x00, 0x0e, 0x00, 0x1b, 0x00, 0x10,
     0x00, 0x1c, 0x00, 0x10, 0x00, 0x16, 0x00, 0x04, 0x00, 0x15, 0x00, 0x04, 0x00, 0x01, 0x00, 0x04,
     0x00, 0x02, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x07, 0x00, 0x02,
     0x00, 0x0b, 0x00, 0x02, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x3c, 0x00, 0x01,
     0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x34, 0x08, 0x01, 0x00, 0x0b, 0x00, 0x1b, 0x00, 0x10,
     0x00, 0x1c, 0x00, 0x10, 0x00, 0x16, 0x00, 0x04, 0x00, 0x15, 0x00, 0x04, 0x00, 0x01, 0x00, 0x04,
     0x00, 0x02, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x8b, 0x00, 0x02,
     0x00, 0x3c, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x03, 0x00, 0x1e, 0x01, 0x00, 0x00, 0x05,
     0x00, 0x01, 0x00, 0x8f, 0x00, 0x04, 0x00, 0xa0, 0x00, 0x08, 0x01, 0x31, 0x00, 0x04, 0x01, 0x32,
     0x00, 0x04, 0x01, 0x30, 0x00, 0x02, 0x01, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x04, 0xbc, 0x00, 0x00,
     0x01, 0x83, 0xdc, 0x83, 0x41, 0x87, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
     0x04, 0x00, 0x00, 0xf4, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x06, 0x9f,
     0x00, 0x00, 0x06, 0x9f, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xdd, 0xe4, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
     0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x06, 0x9f, 0x00, 0x00, 0x06, 0x9f, 0x00, 0x00, 0x00, 0x3c,
     0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdd, 0xe4, 0x80, 0xe8,
     0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x12, 0xa2,
     0x00, 0x00, 0x12, 0xa2, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xdd, 0xf0, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
     0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x12, 0xa2, 0x00, 0x00, 0x12, 0xa2, 0x00, 0x00, 0x00, 0x3c,
     0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdd, 0xf0, 0x80, 0xe8,
     0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x1e, 0x7b,
     0x00, 0x00, 0x1e, 0x7b, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xdd, 0xfc, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
     0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x1e, 0x7b, 0x00, 0x00, 0x1e, 0x7b, 0x00, 0x00, 0x00, 0x3c,
     0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdd, 0xfc, 0x80, 0xe8,
     0x06, 0x02, 0x04, 0x00,
    ];

    let pkt2_wire = [
    0x00, 0x0a, 0x05, 0x64, 0x63, 0x4a, 0xe2, 0xd9, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x05, 0x54, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x2a, 0x36,
    0x00, 0x00, 0x2a, 0x36, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xde, 0x04, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x2a, 0x36, 0x00, 0x00, 0x2a, 0x36, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0x04, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x36, 0x00,
    0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0x90, 0x7a, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x7a, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x41, 0xb9,
    0x00, 0x00, 0x41, 0xb9, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0x90, 0x7e, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x41, 0xb9, 0x00, 0x00, 0x41, 0xb9, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x7e, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x4d, 0x74,
    0x00, 0x00, 0x4d, 0x74, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0x90, 0x8c, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x4d, 0x74, 0x00, 0x00, 0x4d, 0x74, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x8c, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x59, 0x2f,
    0x00, 0x00, 0x59, 0x2f, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xd6, 0xf2, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x59, 0x2f, 0x00, 0x00, 0x59, 0x2f, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd6, 0xf2, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x64, 0xe9,
    0x00, 0x00, 0x64, 0xe9, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xd6, 0xf6, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x64, 0xe9, 0x00, 0x00, 0x64, 0xe9, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd6, 0xf6, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x70, 0xa3,
    0x00, 0x00, 0x70, 0xa3, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xd6, 0xfe, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x70, 0xa3, 0x00, 0x00, 0x70, 0xa3, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd6, 0xfe, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x7c, 0x5c,
    0x00, 0x00, 0x7c, 0x5c, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xd6, 0x68, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x7c, 0x5c, 0x00, 0x00, 0x7c, 0x5c, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd6, 0x68, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x88, 0x17,
    0x00, 0x00, 0x88, 0x18, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xd6, 0x74, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x88, 0x17, 0x00, 0x00, 0x88, 0x18, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd6, 0x74, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x93, 0xd0,
    0x00, 0x00, 0x93, 0xd0, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xd6, 0x76, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x93, 0xd0, 0x00, 0x00, 0x93, 0xd0, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd6, 0x76, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0x9f, 0x8b,
    0x00, 0x00, 0x9f, 0x8c, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xd6, 0x7c, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0x9f, 0x8b, 0x00, 0x00, 0x9f, 0x8c, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd6, 0x7c, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0xab, 0x46,
    0x00, 0x00, 0xab, 0x46, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0x87, 0xd0, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0xab, 0x46, 0x00, 0x00, 0xab, 0x46, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xd0, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0xb6, 0xfe,
    0x00, 0x00, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0x87, 0xde, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0xb6, 0xfe, 0x00, 0x00, 0xb7, 0x01, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xde, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0xc3, 0x96,
    0x00, 0x00, 0xc3, 0x97, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0x87, 0xec, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0xc3, 0x96, 0x00, 0x00, 0xc3, 0x97, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xec, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0xcf, 0x4f,
    0x00, 0x00, 0xcf, 0x4f, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xc3, 0xb8, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0xcf, 0x4f, 0x00, 0x00, 0xcf, 0x4f, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xb8, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0xdb, 0x09,
    0x00, 0x00, 0xdb, 0x0a, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xc3, 0xbe, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0xdb, 0x09, 0x00, 0x00, 0xdb, 0x0a, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xbe, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x01, 0xc0, 0xa8, 0x38, 0x0a, 0x00, 0x00, 0xe6, 0xc5,
    0x00, 0x00, 0xe6, 0xc5, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xe8, 0xc3, 0xc8, 0x06, 0x14, 0x04, 0x00, 0xc0, 0xa8, 0x38, 0x0a,
    0xc0, 0xa8, 0x38, 0x01, 0x00, 0x00, 0xe6, 0xc5, 0x00, 0x00, 0xe6, 0xc5, 0x00, 0x00, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xc8, 0x80, 0xe8,
    0x06, 0x02, 0x04, 0x00];

    let (_, _pkt1) = IpfixPacket::from_wire(Span::new(&pkt1_wire), templates_map.clone()).unwrap();
    let (_, _pkt2)  = IpfixPacket::from_wire(Span::new(&pkt2_wire), templates_map.clone()).unwrap();

    // TODO: test writing complex packets
    Ok(())
}
