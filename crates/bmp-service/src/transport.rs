// Copyright (C) 2022-present The NetGauze Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Generic Transport tooling

//! Example
//! ```no_run
//! use futures_util::StreamExt;
//! use netgauze_bmp_pkt::{
//!     codec::{BmpCodec, BmpCodecDecoderError},
//!     BmpMessage,
//! };
//! use netgauze_bmp_service::{
//!     server::BmpServerResponse,
//!     transport::{TaggedFramedReadStream, TaggedFramedReadStreamResult},
//!     AddrInfo,
//! };
//! use std::net::SocketAddr;
//! use tokio::net::TcpListener;
//! use tokio_util::codec::FramedRead;
//!
//! type BmpResult = TaggedFramedReadStreamResult<AddrInfo, BmpMessage, BmpCodecDecoderError>;
//!
//! #[tokio::main]
//! async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync + 'static>> {
//!     let local_socket = SocketAddr::from(([0, 0, 0, 0], 33000));
//!     let listener = TcpListener::bind(local_socket).await?;
//!     loop {
//!         let (tcp_stream, remote_socket) = listener.accept().await?;
//!         let (rx, tx) = tcp_stream.into_split();
//!         let addr_info = AddrInfo::new(local_socket, remote_socket);
//!         let mut bmp_stream = TaggedFramedReadStream::new(
//!             addr_info,
//!             FramedRead::new(rx, BmpCodec::default()),
//!             Some(tx),
//!         );
//!         while let Some(tagged) = bmp_stream.next().await {
//!             println!("Received message: {:?}", tagged);
//!         }
//!     }
//! }
//! ```

use crate::TaggedData;
use futures_core::{Stream, TryStream};
use pin_project::pin_project;
use std::{
    fmt::Debug,
    pin::Pin,
    task::{Context, Poll},
};
use tokio::io::{AsyncRead, AsyncWrite};
use tokio_util::codec::{Decoder, FramedRead};

/// Result Generated by [`TaggedFramedReadStream`]
pub type TaggedFramedReadStreamResult<Tag, Data, Error> =
    Result<TaggedData<Tag, Data>, TaggedData<Tag, Error>>;

/// Accept an input stream that implements [`AsyncRead`] and a `tag` that
/// implements [`Copy`], then for each input from the input stream produce a
/// [`TaggedData`] with the original input from the stream and a copy of the
/// tag.
///
/// Note, the sender which implements [`AsyncWrite`] is optional, in case we
/// need keep bidirectional connections such as TCP open. By passing the write
/// side of the connection and keeping it, we guarantee that both sides of the
/// connection are closed at the same time.
#[derive(Debug)]
#[pin_project]
pub struct TaggedFramedReadStream<
    RX: AsyncRead,
    TX,
    Tag: Copy,
    Data,
    Error,
    Codec: Decoder<Item = Data, Error = Error>,
> {
    tag: Tag,
    #[pin]
    framed: FramedRead<RX, Codec>,
    _tx: Option<TX>,
}

impl<
        RX: AsyncRead + Unpin,
        TX: AsyncWrite,
        Tag: Copy,
        Data,
        Error,
        Codec: Decoder<Item = Data, Error = Error>,
    > TaggedFramedReadStream<RX, TX, Tag, Data, Error, Codec>
{
    pub const fn new(tag: Tag, framed: FramedRead<RX, Codec>, tx: Option<TX>) -> Self {
        Self {
            tag,
            framed,
            _tx: tx,
        }
    }

    pub const fn tag(&self) -> Tag {
        self.tag
    }
}

impl<
        RX: AsyncRead + Unpin,
        TX: AsyncWrite,
        Tag: Debug + Copy,
        Data,
        Error,
        Codec: Decoder<Item = Data, Error = Error>,
    > Stream for TaggedFramedReadStream<RX, TX, Tag, Data, Error, Codec>
where
    Self: Unpin,
{
    type Item = TaggedFramedReadStreamResult<Tag, Data, Error>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let tag = self.tag;
        let this = self.project();
        let mut framed: Pin<_> = this.framed;
        framed.as_mut().try_poll_next(cx).map(|msg_option| {
            msg_option.map(|result| {
                result
                    .map(|msg| TaggedData::new(tag, msg))
                    .map_err(|err| TaggedData::new(tag, err))
            })
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use futures::StreamExt;
    use netgauze_bmp_pkt::{
        codec::{BmpCodec, BmpCodecDecoderError},
        iana::UndefinedBmpVersion,
        v3::*,
        wire::deserializer::BmpMessageParsingError,
        *,
    };
    use tokio_test::io::Builder;

    #[tokio::test]
    async fn read() {
        let good_wire = [3, 0, 0, 0, 14, 5, 0, 0, 0, 4, 116, 101, 115, 116];
        let good = BmpMessage::V3(BmpV3MessageValue::Termination(TerminationMessage::new(
            vec![TerminationInformation::String("test".to_string())],
        )));
        let bad_wire1 = [0x03, 0x00, 0x00, 0x00, 0x01, 0xff];
        let bad_wire2 = [0xff];
        let read_mock = Builder::new()
            .read(&good_wire)
            .read(&bad_wire1)
            .read(&good_wire)
            .read(&bad_wire2)
            .build();
        let write_mock = Builder::new().build();
        let tag = 1;

        let mut stream = TaggedFramedReadStream::new(
            tag,
            FramedRead::new(read_mock, BmpCodec::default()),
            Some(write_mock),
        );
        assert_eq!(
            stream.next().await,
            Some(Ok(TaggedData::new(tag, good.clone())))
        );
        assert_eq!(
            stream.next().await,
            Some(Err(TaggedData::new(
                tag,
                BmpCodecDecoderError::BmpMessageParsingError(
                    BmpMessageParsingError::InvalidBmpLength(1)
                )
            )))
        );
        assert_eq!(stream.next().await, None);
        assert_eq!(
            stream.next().await,
            Some(Err(TaggedData::new(
                tag,
                BmpCodecDecoderError::BmpMessageParsingError(
                    BmpMessageParsingError::UndefinedBmpVersion(UndefinedBmpVersion(0xff))
                )
            )))
        );
        assert_eq!(stream.next().await, None);
        assert_eq!(
            stream.next().await,
            Some(Ok(TaggedData::new(tag, good.clone())))
        );
    }
}
